;;; ido-config.el --- Configure ido

;;; Commentary:

;; Usage:
;; (require 'ido-config)

;;; Code:

(require 'ag)
(require 'ido)
(require 'ido-occur)
;; Colors
(face-spec-set 'ido-subdir '((t (:foreground "#66ff00"))))
(face-spec-set 'ido-first-match '((t (:foreground "#ccff66"))))
(face-spec-set 'ido-only-match '((t (:foreground "#ffcc33"))))
(face-spec-set 'ido-indicator '((t (:foreground "#ffffff"))))
(face-spec-set 'ido-incomplete-regexp '((t (:foreground "#ffffff"))))
;; ido mode
(setq ido-enable-flex-matching t
      ido-max-prospects 20
      ido-use-filename-at-point 'guess
      ido-create-new-buffer 'always
      ido-use-virtual-buffers t)

(ido-mode 1)
(ido-everywhere 1)

;; old like-ido completion
(icomplete-mode 1)

;; ido-completing-read+
(require 'ido-completing-read+)
(ido-ubiquitous-mode 1)
(require 'crm-custom)
(crm-custom-mode 1)

;; ido-at-point
(require 'ido-at-point)
(ido-at-point-mode)

;; hippy-expand with ido
(defun hippie-completion-at-point ()
  (let ((bounds (bounds-of-thing-at-point 'symbol))
        (expands (hippie-expand-completions)))
    (when (and bounds expands)
      (let* ((beg (car bounds))
             (end (cdr bounds))
             (symbol (buffer-substring-no-properties beg end)))
        (list beg end
              (mapcar (lambda (s) (replace-regexp-in-string (concat ".*" (regexp-quote symbol)) symbol s)) expands)
              :exclusive 'no)))))

(defun hippie-expand-completions (&optional hippie-expand-function)
  "Return the full list of possible completions generated by `hippie-expand'.
    The optional argument can be generated with `make-hippie-expand-function'."
  (let ((this-command 'hippie-expand-completions)
        (last-command last-command)
        (buffer-modified (buffer-modified-p))
        (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
    (cl-letf (((symbol-function 'ding) (lambda ()))) ; avoid the (ding) when hippie-expand exhausts its options.
      (while (progn
                   (funcall hippie-expand-function nil)
                   (setq last-command 'hippie-expand-completions)
                   (not (equal he-num -1)))))
    ;; Evaluating the completions modifies the buffer, however we will finish
    ;; up in the same state that we began.
    (set-buffer-modified-p buffer-modified)
    ;; Provide the options in the order in which they are normally generated.
    (delete he-search-string (reverse he-tried-table))))

(defun ido-hippie-expand-with (hippie-expand-function)
  "Offer ido-based completion using the specified hippie-expand function."
  (let* ((options (hippie-expand-completions hippie-expand-function))
         (selection (and options
                         (ido-completing-read "Completions: " options))))
    (if selection
        (he-substitute-string selection t)
      (message "No expansion found"))))

(defun ido-hippie-expand ()
  "Offer ido-based completion for the word at point."
  (interactive)
  (ido-hippie-expand-with 'hippie-expand))

;; Dangerous
;; (setcdr (last completion-at-point-functions) '(hippie-completion-at-point))

;; semantic with ido
(defun ido-semantic-complete-jump (sym)
  (interactive (list
                (thing-at-point 'symbol)))
  (let ((tags (custom/semantic/deep-brute-tags-query sym))
        chosen-tag)
    (if (< 1 (length tags))
        (let* ((summaries (mapcar #'custom/semantic/tag-summary tags))
               (chosen-summary (ido-completing-read "Choose tag: "
                                                    summaries)))
          (setq chosen-tag (custom/semantic/get-tag-by-summary chosen-summary
                                                          tags)))
      (setq chosen-tag (car tags)))
    (if chosen-tag
        (progn
          (if (boundp 'semantic-tags-location-ring)
              (ring-insert semantic-tags-location-ring (point-marker)))
          (push-mark)
          (find-file (nth 2 chosen-tag))
          (goto-char (nth 3 chosen-tag))
          (recenter)
          (pulse-momentary-highlight-region (nth 3 chosen-tag)
                                            (nth 4 chosen-tag)))
      (select-window (get-buffer-window (ag/search sym (ag/project-root default-directory)))))))

(defun custom/semantic/tag-summary (tag)
  (format "%s:%s -> %s"
          (nth 0 tag)
          (nth 1 tag)
          (nth 2 tag)))

(defun custom/semantic/get-tag-by-summary (summary tags)
  (let ((res nil))
    (dolist (tag tags)
      (if (and (not res)
               (string= summary
                        (custom/semantic/tag-summary tag)))
          (setq res tag)))
    res))

(defun custom/semantic/deep-brute-tags-query (sym &optional buff)
  (let ((acc nil))
    (dolist (tag (semanticdb-strip-find-results
                  (semanticdb-brute-deep-find-tags-for-completion
                   sym
                   (if buff buff (current-buffer)))
                  t))
      (if (semantic-tag-buffer tag)
          (setq acc (push (list (semantic-tag-class tag)
                                (semantic-tag-name tag)
                                (buffer-file-name (semantic-tag-buffer tag))
                                (semantic-tag-start tag)
                                (semantic-tag-end tag))
                          acc))))
    acc))

;; ido recentf
(defun ido-recentf-open ()
  "Use `ido-completing-read' to find a recent file."
  (interactive)
  (if (find-file (ido-completing-read "Find recent file: " recentf-list))
      (message "Opening file...")
    (message "Aborting")))

;; smex
(smex-initialize) ; Can be omitted. This might cause a (minimal) delay
                  ; when Smex is auto-initialized on its first run.
(global-set-key (kbd "M-x") 'smex)
(global-set-key (kbd "M-X") 'smex-major-mode-commands)
;; This is your old M-x.
(global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
;; ido keys
(advice-add 'ido-setup-completion-map :after (lambda ()
                                               (define-key ido-completion-map (kbd "C-v") 'ido-preview)
                                               (define-key ido-completion-map (kbd "C-s") 'ido-preview-next)
                                               (define-key ido-completion-map (kbd "C-r") 'ido-preview-prev)))
(bind-keys
 ("M-i"     . ido-occur-at-point)
 ("M-I"     . ido-occur-from-isearch)
 ("C-x C-r" . ido-recentf-open))


(provide 'ido-config)
;;; ido-config.el ends here
